# Thomas Zhang. 
# AndrewID: tczhang
# 02604-Bioinformatics Week 2 Code submission

def StringReconstruction(Patterns: list[str]) -> str:
    """
    StringReconstruction reconstructs a string from a list of k-mers.

    Input:
        Patterns: The list of k-mers.
    
    Output:
        Text: The reconstructed string.
    """
    dB = DeBruijnKmers(Patterns)
    path = EulerianPath(dB)
    Text = GenomePath(path)
    return Text

def MaximalNonBranchingPaths(G: dict[int, list[int]]) -> list[list[int]]:
    """
    MaximalNonBranchingPaths finds all the non-branching paths in a graph and returns those paths in a list.
    Each path is represented as a list of vertices.

    Input:
        G : The graph represented as an adjacency dictionary.
    
    Output:
        paths : The non-branching paths in a list. Each path is a list of vertices.
    """
    traveled = {}
    in_degree, out_degree = InOutDegree(G)
    paths = []
    for vertex in G:
        if (in_degree[vertex] != 1) or (out_degree[vertex] != 1):
            if out_degree[vertex] > 0:
                traveled[vertex] = True
                for x in G[vertex]:
                    NonBranchingPath = [vertex, x]
                    traveled[x] = True
                    while (in_degree[x] == 1) and (out_degree[x] == 1):
                        NonBranchingPath.append(G[x][0])
                        traveled[G[x][0]] = True
                        x = G[x][0]
                    paths.append(NonBranchingPath)

    for vertex in G:
        if vertex not in traveled:
            if (in_degree[vertex] == 1) and (out_degree[vertex] == 1):
                NonBranchingPath = [vertex]
                traveled[vertex] = True
                
                x = G[vertex][0]
                while x not in traveled:
                    NonBranchingPath.append(x)
                    traveled[x] = True
                    x = G[x][0]
                NonBranchingPath.append(x)
                paths.append(NonBranchingPath)
    
    return paths

def KUniversalString(k: int) -> str:
    """
    Generates the K-universal string.

    Input:
        k : The length of each kmer.
    
    Output:
        Text: the universal string.
    """
    patterns = GenerateBinaryKMers(k)
    Text = StringReconstruction(patterns)
    Text = Text[:len(Text)+1-k]
    return Text

def GenerateBinaryKMers(K: int) -> list[str]:
    """
    GenerateKMers generates all binary kmers of length k.

    Input:
        K : The length of each k-mer.
    
    Output:
        kmers : The list of k-mers.
    """
    kmers = []
    for i in range(2**K):
        kmers.append(f"{i:0{K}b}")
    return kmers

def GenomePath(path: list[str]) -> str:
    """
    Takes a sequence path of k-mers Pattern1, … ,Patternn such that the last k - 1 symbols of Pattern_i are equal 
    to the first k-1 symbols of Pattern_i+1 for 1 ≤ i ≤ n-1. Returns a string of Text of length k+n-1 such that the 
    it-th k-mer in Text is equal to Pattern_i (for 1 ≤ i ≤ n).

    Input: 
        path : the list of patterns.\n
    
    Output:
        FinalString : the final string of text
    """
    k = len(path[0])
    FinalString = ""
    for i, string in enumerate(path):
        if i == 0:
            FinalString = FinalString + string
        else:
            FinalString = FinalString + string[k-1]
    return FinalString

def EulerianCycle(G: dict[int, list[int]]) -> list[int]:
    """
    Takes a graph containing an Eulerian cycle and returns the path of a eulerian cycle.
    
    Input:
        G: A dictionary of edges. Keys are a vertex. Values are list of vertices that edge connects to.
    
    Output:
        path: A list of vertices corresponding to the eulerian cycle path.
    """
    num_edges = 0
    for key in G:
        num_edges += len(G[key])
    path = [list(G)[0]] # Arbitrary start vertex (since graph contains eulerian cycle).
    while num_edges > 0:
        last_vertex = path[len(path)-1] # last vertex visited.
        if not G[last_vertex]: # Check if last_vertex has any unvisited neighbors.
            # Need to choose another starting position
            for index, vertex in enumerate(path):
                if G[vertex]:
                    path = path[index:-1]+path[:index]+[vertex]
                    break
        else:
            # Keep traversing
            path.append(G[last_vertex][0])
            G[last_vertex] = G[last_vertex][1:] # Remove edge we've traversed on.
            num_edges -= 1
    return path

def EulerianPath(G: dict[int, list[int]]) -> list[int]:
    """
    EulerianPath finds the eulerian path in a graph.
    
    Input:
        G : A graph containing a eulerian path. Represented as a dictionary of edges.

    Output:
        path: The eulerian path, as a list of vertices.
    """
    in_degree, out_degree = InOutDegree(G)
    in_out_degree = {}
    for key in in_degree:
        in_out_degree[key] = in_degree[key]
    for key in out_degree:
        if key in in_out_degree:
            in_out_degree[key] -= out_degree[key]
        else:
            in_out_degree[key] = -out_degree[key]

    # Finding the starting and ending vertex
    num_unbalanced = 0
    for key in in_out_degree:
        if in_out_degree[key] == -1:
            start_vertex = key
            num_unbalanced += 1
        elif in_out_degree[key] == 1:
            end_vertex = key
            num_unbalanced += 1
    if num_unbalanced > 2:
        print("Warning: Graph does not have Eulerian Path.")
    
    # Adding an edge so we make the graph contain eulerian cycle.
    if num_unbalanced == 2:
        if end_vertex in G:
            G[end_vertex].append(start_vertex)
        else:
            G[end_vertex] = [start_vertex]

    cycle = EulerianCycle(G)
    if num_unbalanced == 2:
        for index, val in enumerate(cycle[:-1]):
            next_val = cycle[index+1]
            if (val == end_vertex) and (next_val == start_vertex):
                path = cycle[index+1:-1]+cycle[:index+1]
                return path
    else:
        return cycle

    print("Something broke if this prints.")
        
def InOutDegree(G: dict[int, list[int]]) -> tuple[dict[int, int], dict[int, int]]:
    """
    InOutDegree: Determines the in and out degrees of all vertices in a graph.

    Input:
        G: A graph represnted as an adjacency list. The adjacency list is stored as a dictionary.

    Output:
        in_degree, out_degree: Two dictionaries that store the in and out degrees of each vertex in G.
    """
    in_degree = {}
    out_degree = {}
    for key in G:
        for val in G[key]:
            if key in out_degree:
                out_degree[key] += 1
            else:
                out_degree[key] = 1
            
            if val in in_degree:
                in_degree[val] += 1
            else:
                in_degree[val] = 1

            if key not in in_degree:
                in_degree[key] = 0
            if val not in out_degree:
                out_degree[val] = 0
                
    return in_degree, out_degree

def DeBruijnKmers(k_mers: list[str]) -> dict[str, list[str]]:
    """
    Creates an adjacency dict for the DebruijnKmers graph based on a list of k mers.

    Input:
        k_mers : A list of k-mers.
    
    Output:
        AdjacencyDict : The adjacency list of the DeBruijn graph formed from k_mers.
        Adjacency list is represented as a dictionary.
    """
    AdjacencyDict = {}
    for Kmer in k_mers:
        Key = Kmer[:-1]
        if Key in AdjacencyDict:
            AdjacencyDict[Kmer[:-1]].append(Kmer[1:])
        else:
            AdjacencyDict[Kmer[:-1]] = [Kmer[1:]]
    return AdjacencyDict

def ContigGeneration(Patterns: list[str]) -> list[str]:
    """
    ContigGeneration finds the contigs from the DeBruijn graph generated from a collection of k-mers.

    Input:
        Patterns : The collection of K-mers.

    Output:
        contigs : The list of contigs.
    """
    G = DeBruijnKmers(Patterns)
    contig_paths = MaximalNonBranchingPaths(G)
    contigs = []
    for contig_path in contig_paths:
        contig = GenomePath(contig_path)
        contigs.append(contig)

    return contigs